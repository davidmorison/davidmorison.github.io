<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
* {box-sizing: border-box}
body {font-family: Verdana, sans-serif; margin:0}
.mySlides {display: none}
img {vertical-align: middle;}

/* Slideshow container */
.slideshow-container {
  max-width: 1000px;
  position: relative;
  margin: auto;
}

/* Next & previous buttons */
.prev, .next {
  cursor: pointer;
  position: absolute;
  top: 50%;
  width: auto;
  padding: 16px;
  margin-top: -22px;
  color: green;
  font-weight: bold;
  font-size: 18px;
  transition: 0.6s ease;
  border-radius: 0 3px 3px 0;
  user-select: none;
}

/* Position the "next button" to the right */
.next {
  right: 0;
  border-radius: 3px 0 0 3px;
}

/* On hover, add a black background color with a little bit see-through */
.prev:hover, .next:hover {
  background-color: rgba(0,0,0,0.8);
}

/* Caption text */
.text {
  color: #000000;
  font-size: 15px;
  padding: 8px 12px;
  position: absolute;
  bottom: 8px;
  width: 100%;
  text-align: center;
}

/* Number text (1/3 etc) */
.numbertext {
  color: #000000;
  font-size: 12px;
  padding: 8px 12px;
  position: absolute;
  top: 0;
}

/* The dots/bullets/indicators */
.dot {
  cursor: pointer;
  height: 15px;
  width: 15px;
  margin: 0 2px;
  background-color: #bbb;
  border-radius: 50%;
  display: inline-block;
  transition: background-color 0.6s ease;
}

.active, .dot:hover {
  background-color: #717171;
}

/* Fading animation */
.fade {
  -webkit-animation-name: fade;
  -webkit-animation-duration: 1.5s;
  animation-name: fade;
  animation-duration: 1.5s;
}

@-webkit-keyframes fade {
  from {opacity: .4} 
  to {opacity: 1}
}

@keyframes fade {
  from {opacity: .4} 
  to {opacity: 1}
}

/* On smaller screens, decrease text size */
@media only screen and (max-width: 300px) {
  .prev, .next,.text {font-size: 11px}
}
</style>
</head>
<body>

<div class="slideshow-container">

<div class="mySlides fade">
  <div class="numbertext">1 / 9</div>
  <img src="./images4blup/non_navy.png"              style="width:100%">
  <br><br><br>
  <div class="text">
    Working on an easy to deploy method for ocean current from observed buoy tracks, we utilized Kriging as a general and straightforward method of predicting stationary random fields from limited observations. Yet, we want to use more of the information provided by ensemble forecasts or other simulations. Optimal interpolation offers a lightweight method for combining prior knowledge with data.
 </div>
</div>

<div class="mySlides fade">
  <div class="numbertext">2 / 9</div>
  <img src="./images4blup/two_types_of_data.png"         style="width:100%">
  <br><br><br><br><br><br>
  <div class="text">
    Linear regression seems to be the most widely utilized method from linear statistics. This method's setting is when independent variables plus identically and independently distributed noise combine to create a dependant variable. When random fields are spatially correlated, Kriging methods become appropriate. A wealth of methods intermix the methods of and assumptions of Kriging and linear regression. Optimal interpolation and BLUP (best linear unbiased prediction) are two methods that combine detailed regressors and expected measurement covariance.
 </div>
</div>

<div class="mySlides fade">
  <div class="numbertext">3 / 9</div>
  <img src="./images4blup/could_sto.png"        style="width:100%">
  <br><br>
  <div class="text">
    For a small number of observations, indicated by red dots, an underlying process could be a spatially correlated random field.
 </div>
</div>

<div class="mySlides fade">
  <div class="numbertext">4 / 9</div>
  <img src="./images4blup/could_hom.png"    style="width:100%">
  <br><br>
  <div class="text">
    Or, an identical data set could arise from a linear trend plus independently distributed noise.
 </div>
</div>

<div class="mySlides fade">
  <div class="numbertext">5 / 9</div>
  <img src="./images4blup/two_covariograms.png"          style="width:100%">
  <br><br><br><br><br><br>
  <div class="text">
    These covariograms will help illustrate the flexibility of optimal interpolation. The x-axis is the absolute difference in the dependant variable between two data points. The y-axis is the expected covariance between stationary random field values at locations separated by x. A family of blue lines indicates varying degrees of spatial covariance. Independent noise corresponds to a single blue dot on the y-axis at x=0 and zero covariance everywhere else. The left and right illustrate different transitions from the assumption of spatial correlation to independent noise.
 </div>
</div>

<div class="mySlides fade">
  <div class="numbertext">6 / 9</div>
  <img src="./images4blup/red_const.png"                 style="width:100%">
  <br><br><br><br><br><br>
  <div class="text">
    With a lone regressor equal to a constant offset, optimal interpolation is equivalent to ordinary Kriging. There is no "true" or correct underlying process. The red dots are the same made-up data throughout this slideshow. Dark blue lines indicate the expected values, and light blue indicates confidence intervals. The family of ten lines in each panel demonstrates the variety of predictions arising from the covariograms in the previous slide.        
 </div>
</div>

<div class="mySlides fade">
  <div class="numbertext">7 / 9</div>
  <img src="./images4blup/red_lin.png"                   style="width:100%">
  <br><br><br>
  <div class="text">
    Here, we include a linear trend regressor.
 </div>
</div>

<div class="mySlides fade">
  <div class="numbertext">8 / 9</div>
  <img src="./images4blup/red_parab.png"                 style="width:100%">
  <br><br><br>
  <div class="text">
    Now, a second-order polynomial is allowed.
 </div>
</div>

<div class="mySlides fade">
  <div class="numbertext">9 / 9</div>
  <img src="./images4blup/red_trig.png"                  style="width:100%">
  <br><br><br><br><br><br><br><br>
  <div class="text">
    We have yet to discuss any empirical considerations, but in this graphic a trigonometric function has been used as a regressor. Prior information about any cyclic structure may enter into the regressors.
    As a hypothetical, consider having access to ensemble weather forecast data. Empirical orthogonal functions or principal component analysis can approximate the structure and variability of large-scale weather patterns and provide regressors. Then the residual variation of the ensemble forecasts can guide the choice or design of covariograms.
    State of the art data assimilation for weather models requires the collaboration of experts in multiple scientific fields. In contrast, the approach suggested here is tractable for a single researcher. Optimal interpolation can bring much of the information from the ensemble forecasts to bear on observations' assimilation.
 </div>
</div>

<a class="prev" onclick="plusSlides(-1)">&#10094;</a>
<a class="next" onclick="plusSlides(1)">&#10095;</a>

</div>
<br>

<div style="text-align:center">
  <span class="dot" onclick="currentSlide(1)"></span> 
  <span class="dot" onclick="currentSlide(2)"></span> 
  <span class="dot" onclick="currentSlide(3)"></span> 
  <span class="dot" onclick="currentSlide(4)"></span> 
  <span class="dot" onclick="currentSlide(5)"></span> 
  <span class="dot" onclick="currentSlide(6)"></span> 
  <span class="dot" onclick="currentSlide(7)"></span> 
  <span class="dot" onclick="currentSlide(8)"></span> 
  <span class="dot" onclick="currentSlide(9)"></span> 
</div>

<script>
var slideIndex = 1;
showSlides(slideIndex);

function plusSlides(n) {
  showSlides(slideIndex += n);
}

function currentSlide(n) {
  showSlides(slideIndex = n);
}

function showSlides(n) {
  var i;
  var slides = document.getElementsByClassName("mySlides");
  var dots = document.getElementsByClassName("dot");
  if (n > slides.length) {slideIndex = 1}    
  if (n < 1) {slideIndex = slides.length}
  for (i = 0; i < slides.length; i++) {
      slides[i].style.display = "none";  
  }
  for (i = 0; i < dots.length; i++) {
      dots[i].className = dots[i].className.replace(" active", "");
  }
  slides[slideIndex-1].style.display = "block";  
  dots[slideIndex-1].className += " active";
}
</script>

</body>
</html> 

